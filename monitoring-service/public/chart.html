<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL History Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .url-select {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .url-checkbox {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
        }
        .url-checkbox input {
            margin-right: 5px;
        }
        .date-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .date-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <h1>URL History Dashboard</h1>
        
        <div class="controls">
            <div class="date-controls">
                <div class="date-group">
                    <label for="startDate">Start Date</label>
                    <input type="date" id="startDate" value="2024-01-01">
                </div>
                <div class="date-group">
                    <label for="endDate">End Date</label>
                    <input type="date" id="endDate" value="2024-01-31">
                </div>
            </div>

            <label>Select URLs to Monitor:</label>
            <div class="url-select" id="urlSelect"></div>
        </div>

        <div class="chart-container">
            <canvas id="uptimeChart"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="responseTimeChart"></canvas>
        </div>
    </div>

    <script>
        // Sample historical data (simulating database records)
        const historicalData = {
            'google.com': Array.from({length: 31}, (_, i) => ({
                date: `2024-01-${String(i + 1).padStart(2, '0')}`,
                uptime: 95 + Math.random() * 5,
                responseTime: 100 + Math.random() * 100
            })),
            // 'github.com': Array.from({length: 31}, (_, i) => ({
            //     date: `2024-01-${String(i + 1).padStart(2, '0')}`,
            //     uptime: 93 + Math.random() * 7,
            //     responseTime: 150 + Math.random() * 100
            // })),
            // 'kubernetes.io': Array.from({length: 31}, (_, i) => ({
            //     date: `2024-01-${String(i + 1).padStart(2, '0')}`,
            //     uptime: 90 + Math.random() * 10,
            //     responseTime: 200 + Math.random() * 100
            // }))
        };

        const urls = Object.keys(historicalData);
        let uptimeChart = null;
        let responseTimeChart = null;

        // Initialize URL checkboxes
        function initializeURLSelect() {
            const urlSelect = document.getElementById('urlSelect');
            urls.forEach(url => {
                const label = document.createElement('label');
                label.className = 'url-checkbox';
                label.innerHTML = `
                    <input type="checkbox" value="${url}" checked>
                    ${url}
                `;
                urlSelect.appendChild(label);
            });
        }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function updateCharts() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const selectedUrls = Array.from(document.querySelectorAll('.url-checkbox input:checked'))
                .map(checkbox => checkbox.value);

            // Update Uptime Chart
            const uptimeData = {
                labels: historicalData[urls[0]]
                    .filter(record => record.date >= startDate && record.date <= endDate)
                    .map(record => record.date),
                datasets: selectedUrls.map(url => ({
                    label: url,
                    data: historicalData[url]
                        .filter(record => record.date >= startDate && record.date <= endDate)
                        .map(record => record.uptime),
                    borderColor: getRandomColor(),
                    tension: 0.1,
                    fill: false
                }))
            };

            if (uptimeChart) {
                uptimeChart.destroy();
            }

            uptimeChart = new Chart(document.getElementById('uptimeChart'), {
                type: 'line',
                data: uptimeData,
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            min: 80,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Uptime %'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'URL Uptime History'
                        }
                    }
                }
            });

            // Update Response Time Chart
            const responseTimeData = {
                labels: historicalData[urls[0]]
                    .filter(record => record.date >= startDate && record.date <= endDate)
                    .map(record => record.date),
                datasets: selectedUrls.map(url => ({
                    label: url,
                    data: historicalData[url]
                        .filter(record => record.date >= startDate && record.date <= endDate)
                        .map(record => record.responseTime),
                    borderColor: getRandomColor(),
                    tension: 0.1,
                    fill: false
                }))
            };

            if (responseTimeChart) {
                responseTimeChart.destroy();
            }

            responseTimeChart = new Chart(document.getElementById('responseTimeChart'), {
                type: 'line',
                data: responseTimeData,
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Response Time (ms)'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'URL Response Time History'
                        }
                    }
                }
            });
        }

        // Initialize the dashboard
        function initDashboard() {
            initializeURLSelect();
            updateCharts();

            // Add event listeners
            document.getElementById('startDate').addEventListener('change', updateCharts);
            document.getElementById('endDate').addEventListener('change', updateCharts);
            document.querySelectorAll('.url-checkbox input').forEach(checkbox => {
                checkbox.addEventListener('change', updateCharts);
            });
        }

        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>














<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Health Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .metrics-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .metric-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #e0e0e0;
        }
        .metric-button.active {
            background-color: #2196f3;
            color: white;
        }
        .date-range-picker {
            margin: 20px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        .date-range-picker input {
            margin-right: 10px;
            padding: 5px;
        }
        #uptimeChart {
            margin-top: 20px;
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <h1>URL Health Dashboard</h1>
        
        <div class="metrics-toggle">
            <button class="metric-button active" data-metric="frequency">Visit Frequency</button>
            <button class="metric-button" data-metric="responseTime">Response Time</button>
            <button class="metric-button" data-metric="status">Status Codes</button>
        </div>

        <div class="date-range-picker">
            <input type="date" id="startDate" name="startDate">
            <input type="date" id="endDate" name="endDate">
            <button onclick="calculateUptime()">Show Uptime</button>
        </div>

        <div class="chart-container">
            <canvas id="metricsChart"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="responseTimeChart"></canvas>
        </div>

        <div id="uptimeChart"></div>
    </div>

    <script>
        // Hardcoded data from your MySQL tables
        const urlData = [
            { url: 'google.com', frequency: 100, responseTime: 150, status: 200 },
            { url: 'github.com/trending', frequency: 50, responseTime: 200, status: 200 },
            { url: 'dev.mysql.com/doc', frequency: 25, responseTime: 180, status: 200 },
            { url: 'kubernetes.io/docs', frequency: 75, responseTime: 250, status: 200 },
            { url: 'docs.docker.com', frequency: 30, responseTime: 220, status: 200 },
            { url: 'youtube.com/tech', frequency: 85, responseTime: 190, status: 200 },
            { url: 'stackoverflow.com', frequency: 95, responseTime: 170, status: 200 },
            { url: 'aws.amazon.com/console', frequency: 40, responseTime: 210, status: 200 },
            { url: 'nodejs.org/docs', frequency: 20, responseTime: 160, status: 200 },
            { url: 'golang.org', frequency: 60, responseTime: 140, status: 200 }
        ];

        // Health check data
        const healthData = [
            { url: 'google.com', responseTime: 150, status: 200, isAlive: true },
            { url: 'github.com/trending', responseTime: 200, status: 200, isAlive: true },
            { url: 'dev.mysql.com/doc', responseTime: 180, status: 200, isAlive: true },
            { url: 'kubernetes.io/docs', responseTime: 250, status: 200, isAlive: true },
            { url: 'docs.docker.com', responseTime: 220, status: 200, isAlive: true }
        ];

        // Update data structure to include timestamps
        const healthCheckHistory = [
            {
                url: 'google.com',
                checks: [
                    { timestamp: '2024-03-01T10:00:00', responseTime: 150, status: 200, isAlive: true },
                    { timestamp: '2024-03-01T11:00:00', responseTime: 160, status: 200, isAlive: true },
                    { timestamp: '2024-03-01T12:00:00', responseTime: 500, status: 500, isAlive: false }
                ]
            }
            // Add more URLs...
        ];

        let metricsChart = null;
        let responseTimeChart = null;

        function createMetricsChart(metric) {
            const ctx = document.getElementById('metricsChart');
            
            const chartData = {
                labels: urlData.map(item => item.url),
                datasets: [{
                    label: getMetricLabel(metric),
                    data: urlData.map(item => item[metric]),
                    backgroundColor: '#2196f3',
                    borderColor: '#1976d2',
                    borderWidth: 1
                }]
            };

            if (metricsChart) {
                metricsChart.destroy();
            }

            metricsChart = new Chart(ctx, {
                type: 'bar',
                data: chartData,
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: getMetricLabel(metric) + ' by URL'
                        }
                    }
                }
            });
        }

        function createResponseTimeChart() {
            const ctx = document.getElementById('responseTimeChart');
            
            const chartData = {
                labels: healthData.map(item => item.url),
                datasets: [{
                    label: 'Response Time (ms)',
                    data: healthData.map(item => item.responseTime),
                    borderColor: '#4caf50',
                    backgroundColor: '#4caf50',
                    tension: 0.1
                }]
            };

            if (responseTimeChart) {
                responseTimeChart.destroy();
            }

            responseTimeChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Response Time (ms)'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Response Time Trends'
                        }
                    }
                }
            });
        }

        function getMetricLabel(metric) {
            const labels = {
                frequency: 'Visit Frequency',
                responseTime: 'Response Time (ms)',
                status: 'Status Code'
            };
            return labels[metric] || metric;
        }

        function calculateUptime() {
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            
            const uptimeData = healthCheckHistory.map(site => {
                const checksInRange = site.checks.filter(check => {
                    const checkDate = new Date(check.timestamp);
                    return checkDate >= startDate && checkDate <= endDate;
                });
                
                const successfulChecks = checksInRange.filter(check => check.isAlive).length;
                const uptimePercentage = (successfulChecks / checksInRange.length) * 100;
                
                return {
                    url: site.url,
                    uptime: uptimePercentage.toFixed(2)
                };
            });

            displayUptimeChart(uptimeData);
        }

        function displayUptimeChart(uptimeData) {
            const ctx = document.getElementById('uptimeChart');
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: uptimeData.map(site => site.url),
                    datasets: [{
                        label: 'Uptime %',
                        data: uptimeData.map(site => site.uptime),
                        backgroundColor: 'rgba(54, 162, 235, 0.5)'
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        }

        function initDashboard() {
            createMetricsChart('frequency');
            createResponseTimeChart();

            document.querySelectorAll('.metric-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    document.querySelectorAll('.metric-button').forEach(btn => 
                        btn.classList.remove('active'));
                    e.target.classList.add('active');

                    const metric = e.target.dataset.metric;
                    createMetricsChart(metric);
                });
            });
        }

        // Start the dashboard when the page loads
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html> -->